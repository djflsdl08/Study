4. 클래스와 객체

클래스 - 객체의 행동에 대한 절차, 방법 정의
       - 객체 생성을 위한 설계도 또는 틀,캡슐
       - ex) 붕어빵 틀, 사람(이름,직업,나이,성별...)

객체 - 설계도 또는 틀로 찍어낸 실체( =인스턴스)
     - ex) 붕어빵, 김예진(21,여...)

****
public class Person {
	public String name;  // field

	public Person(){}   // 생성자
	public Person(String s){}   // 매개변수가 있는 생성자
}
public static void main(String[] args){
	Person aPerson;    // 레퍼런스 변수 선언
	                  // Person 객체 생성된것 아님(C++과의 차이)
            		// aPerson은 Person타입의 객체에 대한 레퍼런스 변수
	aPerson = new Person("Kim,Yejin");  // 객체생성!!(new 연산자)
}

****

메소드(클래스의 멤버함수) 활용
- 접근지정자 - public : 클래스 내/외부 모두 호출 가능
	     - private : 클래스 내부 멤버들만 호출 가능
             - protected : 클래스 내부 메소드들 호출 가능
                         : 다른 패키지 중 상속받은 서브 클래스만 호출 가능
                          ex) class B extends A  // B가 A를 상속받음
	     - default : 동일한 패키지 내의 모든 클래스 호출 가능
  * 캡슐화의 원칙이 지켜지도록 데이터 멤버에 대해서는 가능한 private 선언!

- 오버로딩 : 한 클래스 내에 이름이 같지만 인자의 타입과 개수가 서로 다른 메소드 중복작성 가능
           - 이름 동일, 인자의 개수 또는 인자의 타입 다름
           - 리턴타입과 접근지정자는 관계없음

가비지(객체 치환시 가리키는 레퍼런스가 없음) 컬렉션
- 자바 가상 기계가 가용 공간이 없을 때 자동으로 가비지를 회수하여 가용 메모리 공간을 늘리는 경우
- 주체: 가비지 컬렉터- 가비지 컬렉션 스레드
- 가비지 컬렉션 강제수행 : System.gc(); - 자바 가상 기계에게 단지 가비지 컬렉션이 필요하다는 제안

this() - 동일한 클래스 내의 다른 생성자 호출(생성자 코드에서만 사용가능)
       - 반드시 생성자의 첫 번째 문장에 사용

자바에서 객체 소멸은 없음(C++(delete)과의 차이)
-  new로 할당받은 후 사용하지 않게 된 객체는 가비지가 됨

final 키워드
- final 클래스: 클래스를 상속 받을 수 없음
- final 메소드: 자식 클래스가 부모 클래스의 특정 메소드를 오버라이딩 못함
- final 필드: 상수정의(초깃값 설정-변경안됨) 
              프로그램 전체에서 사용할 상수 선언 ex) public static final double PI = 3.141592
